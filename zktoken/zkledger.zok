import "utils/pack/bool/nonStrictUnpack256" as unpack256;
import "hashes/sha256/512bitPacked" as sha256packed;
import "ecc/edwardsOnCurve" as onCurve;
import "ecc/edwardsScalarMult" as multiply;

import "ecc/edwardsAdd" as add;

from "ecc/babyjubjubParams" import BabyJubJubParams;

const BabyJubJubParams context = BabyJubJubParams {

    // Order of the curve for reference: 21888242871839275222246405745257275088614511777268538073601725287587578984328
    JUBJUB_C: 8,      // Cofactor
    JUBJUB_A: 168700, // Coefficient A
    JUBJUB_D: 168696, // Coefficient D

    // Montgomery parameters
    MONT_A: 168698,
    MONT_B: 1,

    // Point at infinity
    INFINITY: [0, 1],

    // Generator
    Gu: 16540640123574156134436876038791482806971768689494387082833631921987005038935,
    Gv: 20819045374670962167435360035096875258406992893633759881276124905556507972311
};

// Generator G
const field[2] G = [16540640123574156134436876038791482806971768689494387082833631921987005038935, 20819045374670962167435360035096875258406992893633759881276124905556507972311];

// Generator H (TODO: Generate this using a nothing up my sleeve setup)
const field[2] H = [18088494987768362437108104365733457390180002882080199252891584927105189390906, 18851452430177667536696249872672129346900883028423229527829953506995373114404];


// getPK is a function that multiplies a scalar with the group generator
// receives the generator and the scalar 'x'
// returns a (x,y) coordinate 
def getPk(field[2] generator, field x) -> field[2]{
    bool[256] xBits = unpack256(x);
    return multiply(xBits, generator, context);
}

// IsOnCurve checks if a point is on the curve
// receives a point (as a field[2])
// returns a true/false if the point is on the curve
def IsOnCurve(field[2] point) -> bool {
    bool ok = onCurve(point, context);
    return ok;
}


// PedersenCommitment is a function that calculates a Pedersen commitment
// receives a value 'v' and a random value 'r'
// returns a Pedersen commitment on BabyJubJub
def PedersenCommitment(field v, field r) -> field[2]{

    // calculate v*G
    field[2] vG = getPk(G, v);

    // calculate r*H 
    field[2] rH = getPk(H, r);

    // calculate vG + rH
    field[2] commit = add(vG, rH, context);
    
    return commit;
}


// KnowledgeOfSK checks if a given secret key corresponds to a given public key
// receives a secret key 'sk' and a public key 'pk'
// returns a true/false if the secret key corresponds to the passed public key
def KnowledgeOfSK(field sk, field[2] pk) -> bool{

    // obtain public key from secret key
    field[2] publickey = getPk(G, sk);

    // compare obtained publickey and passed pk
    bool ok = (publickey[0] == pk[0]) && (publickey[1] == pk[1]);

    return ok;
}


// SumPedersencommits_list calculates the sum of an array of Pedersen commitments
// receives an array of commitments
// returns the total sum in a single commitment
def SumPedersenCommits<N>(field[N][2] commits_list) -> field[2] {

    // initialize commitment variable
    field[2] mut result_commit = [0, 0];
    
    for u32 i in 0..N {
        result_commit = add(result_commit, commits_list[i], context);
    }

    return result_commit;
}


// CheckPedersenCommitmentEquality checks if a passed Pedersen commitment is equal to a Pedersen commitment to a value 'v' and random value 'r'
// receives a previous commitment, a value 'v' and a random value 'r'
// returns a true/false if the obtained commitment is equal to the passed one
def CheckPedersenCommitmentEquality(field[2] commitment, field v, field r) -> bool {

    // Obtain Pedersen commitment
    field[2] commit = PedersenCommitment(v, r); 

    // Check if obtained commitment is status to the passed to the function
    bool status = (commitment[0] == commit[0]) && (commitment[1] == commit[1]);

    return status;
}

// 
def CheckPedersenCommitmentSetEquality<N>(field[N][2] commitment, field[N] v, field[N] r) -> bool {
    
    bool mut status  = true; 

    for u32 i in 0..N {
        // Obtain Pedersen commitment
        field[2] obtained_commitment = PedersenCommitment(v[i], r[i]); 

        // Check if obtained commitment is status to the passed to the function
        status = status && (commitment[i][0] == obtained_commitment[0]) && (commitment[i][1] == obtained_commitment[1]);
    }

    return status;
}

// 
def CheckPedersenCommitmentsOnCurve<N>(field[N][2] commitment, field[N] v, field[N] r) -> bool {
    
    bool mut status = true; 

    for u32 i in 0..N {
        // Obtain Pedersen commitment
        field[2] obtained_commitment = PedersenCommitment(v[i], r[i]); 

        // Check if obtained commitment is status to the passed to the function
        status = status && (IsOnCurve(obtained_commitment));
    }

    return status;
}
   

// CheckRange checks if a value 'v' in a Pedersen Commitment is within a given range
// receives a range, a commitment, a value 'v' and a random value 'r'
// returns a true/false if the value is within the range
def CheckRange (field range, field[2] commitment, field v, field r) -> bool {
        
    // Check if obtained commitment is equal to the passed to the function
    bool status_equality = CheckPedersenCommitmentEquality(commitment, v, r); 

    // Range Check
    bool status_range = if (v >= 0 && v < range) { true } else{ false };

    return status_range && status_equality;
}

// 
def getInverse(field x) -> field {
    
    field p = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    field inverse = p - x;

    return inverse;
}


def main(
    private u32 sender_id,                  // index of the person making the transaction
    private u32[3] destination_id,          // array of destination ids as it may be more than one
    public  field[3][2] public_keys,        // list of public keys from smart contract on main chain
    public  field[3][2] previous_commits,   // list of previous commitments from smart contract on main chain (this is the actual balance)
    private field previous_v,               // previous balance of the commitment of the sender (to make sure he can open it)
    private field previous_r,               // previous random value of the commitment of the sender (to make sure he can open it)
    public  field[100][2] tx_commits,       // list of commitments for the transaction being made
    private field[100] tx_values,           // list of values for the transaction being made
    private field[100] tx_randoms,          // list of random values for the transaction being made
    private field sk,                       // secret key of the sender (to prove that they own the funds)
    private field v,                        // value of the transaction
    private field[2] secrets                // array of the shared secrets with all the other entities in the system
    ) {

    // variable set to true just used for code cleanliness
    bool ok = true; 

    // Check if the public key is on the curve
    bool status_curve = IsOnCurve(public_keys[sender_id]);
    assert(status_curve == ok);

    // Check if the secret key corresponds to the public key for id
    bool status_pk = KnowledgeOfSK(sk, public_keys[sender_id]);
    assert(status_pk == ok);

    // check if user can open the previous commitment
    field[2] obtained_previous_commit = PedersenCommitment(previous_v, previous_r);
    assert(obtained_previous_commit[0] == previous_commits[sender_id][0] && obtained_previous_commit[1] == previous_commits[sender_id][1]);

    // check if user has enough value to send (aka range check)
    bool status_range = if (previous_v >= v) { true } else { false };
    assert(status_range == ok);

    //bool status_range = CheckRange(previous_v, commits_list[sender_id], v[id], r[id]);

    // check that Pedersen commitments of transaction add up to 0, which is point (0, 1)
    field [2] tx_commit_sum = SumPedersenCommits(tx_commits);
    //assert(tx_commit_sum[0] == 0 && tx_commit_sum[1] == 1);
 

    // calculate the random values for the Pedersen commitments of the transaction

    // TODO: update this value
    field r = 123456789;

    // calculate Pedersen commitment for tx and check if sender sent the correct one (to a proper negative value)
    field[2] obtained_tx_commit = PedersenCommitment(getInverse(v), r);
    assert(obtained_tx_commit[0] == tx_commits[sender_id][0] && obtained_tx_commit[1] == tx_commits[sender_id][1]);


    //field[2] obtained_dest_tx_commit = PedersenCommitment(v, getInverse(r[destination_id]));

    // TODO: Fix the index of this array
    //field[2] obtained_extra_tx_commit = PedersenCommitment(0, r[1]);

    
    // check if the Pedersen commitment of the transaction is equal to the obtained Pedersen commitment
    bool status_tx_commit = CheckPedersenCommitmentSetEquality(tx_commits, tx_values, tx_randoms);
    assert(status_tx_commit == ok);



    return ;
}


// TODO LIST

// TODO: Check that person sending the tx knows how to open all commitments (i.e., pass an array of values and an array of random values)
// TODO: Code the transparent setup for generator H
// TODO: Fix the malleability and replay attack
// tbd
